在 `malloc` 的眼里，内存不是杂乱无章的，而是由一个个 **Chunk** 组成的链表。

每个Chunk包含两部分：

**元数据（Metadata）：** 记录这个块的大小、前一个块是否空闲、当前块是否在使用中等。

**用户数据区：** `malloc` 返回给你的指针，实际上是指向这个区域的起始位置。

为了管理这些空闲的 Chunk，`malloc` 维护了一组称为 **Bins** 的数据结构（本质是双向链表）：

- **Fast Bins：** 存放超小内存块，不合并，速度极快（类似缓存）。
- **Unsorted Bin：** 缓存最近释放的块，给它们一次“重获新生”的机会。
- **Small Bins & Large Bins：** 存放不同尺寸范围的块，按大小排序。



### 分配流程：

1. **检查缓存：** 先看 Fast bins 里有没有现成的大小合适的。
2. **查表寻找：** 遍历其他 Bins 寻找匹配的空闲块。
3. **切割（Splitting）：** 如果找到的块太大，就把它切成两半，一半给用户，剩下的一半放回空闲链表。
4. **向内核申请：** 如果 Bins 全空，调用 `brk` 或 `mmap`。

### 释放流程（`free`）：

1. **标记空闲：** 把 Chunk 的状态设为空闲。
2. **合并（Coalescing）：** 检查左右相邻的块是否也空闲。如果是，就把它们连成一个大块，防止**内存碎片**。

当 `malloc` 发现手里的“存货”不够时，它会通过以下两个系统调用向内核申请：

| **方式**   | **系统调用**   | **适用场景**                 | **原理**                                                     |
| ---------- | -------------- | ---------------------------- | ------------------------------------------------------------ |
| **方式 A** | `brk` / `sbrk` | **小额**申请（通常 < 128KB） | 通过移动堆顶指针 `_edata` 来扩大堆空间。                     |
| **方式 B** | `mmap`         | **大额**申请（通常 > 128KB） | 在堆和栈之间的“文件映射区”找一块空闲虚拟内存，映射为匿名页。 |



##  总结：`malloc` 的底层逻辑

1. **虚拟层：** `malloc` 管理的是虚拟地址，而不是物理地址。
2. **效率层：** 通过“批发（brk/mmap）+ 零售（Bins管理）”减少系统调用开销。
3. **策略层：** 针对大小不同的申请，采取不同的分配手段（brk 适合频繁小操作，mmap 适合一次性大操作）。
4. **安全层：** 元数据记录了块的信息，这也是为什么“越界写入”会破坏 `malloc` 结构导致 `double free or corruption` 崩溃的原因。



## Q1: 移动堆顶指针 `brk` 后，物理内存到底哪来的？

你猜得没错，**移动 `brk` 指针的一瞬间，操作系统并没有给你任何物理内存。**

### 1. “签合同”与“给现金”

- **移动 `brk`：** 相当于操作系统在你的进程账本上签了个字，说：“从 A 到 B 这块虚拟地址现在归你了。” 此时，内核只是更新了进程控制块（PCB）中的 `mm_struct`，扩大了堆的覆盖范围。
- **物理内存：** 此时这块内存甚至还没在内存条里“出生”。

### 2. 物理内存的来源：伙伴系统（Buddy System）

只有当你真正去**读写**这块新申请的虚拟内存时，CPU 会发现这块地址在页表中没有对应的物理地址，从而触发**缺页中断**。此时内核才开始干活：

1. 内核去它的**空闲内存池**（由**伙伴系统**管理，专门负责按“页”分配物理内存）里找一块空闲的物理页框（Page Frame）。
2. 把这个物理页框的地址填进你的页表。
3. 程序继续运行，就像什么都没发生过一样。

**结论：** 物理内存来自内核统一管理的**空闲物理页池**。

------

## Q2: 操作系统内存管理的完整流程

为了让你找回记忆，我们可以把这个过程比作**“查字典”**：

1. **CPU 发出请求：** 程序员写下 `ptr[0] = 1;`，CPU 尝试访问一个**虚拟地址 (VA)**。
2. **MMU 硬件转换：** 内存管理单元（MMU）拿到 VA，去查**页表（Page Table）**。
3. **发现异常（缺页）：** * 如果页表条目（PTE）显示该页有效，直接拿到**物理地址 (PA)** 访问内存。
   - 如果页表条目无效（Present位为0），触发**缺页中断 (Page Fault)**。
4. **内核接管：** * 检查该地址是否合法（是否在 `malloc` 申请的范围内）。
   - 若合法，从物理内存池分配一页。
   - **更新页表：** 建立虚拟页到物理页的映射关系。
5. **指令重试：** CPU 重新执行刚才那条指令，这次 MMU 能查到地址了，访问成功。

## 华为风格面试题（含参考答案）

### Q1：请从性能和碎片的角度，对比 malloc 中 brk 和 mmap 的区别？

**参考答案：**

- **分配逻辑：** `brk` 是通过移动堆顶指针来分配，申请的内存依然属于堆区；`mmap` 是在堆栈之间的文件映射区寻找一块空闲的虚拟内存。
- **性能开销：** * `brk` 分配后，`free` 释放时并不一定会立即归还给操作系统（为了复用），这减少了频繁系统调用的开销。
  - `mmap` 每次分配和释放都会触发内核态切换，且释放时会立即解除映射并归还内核，开销较大。
- **内存碎片：**
  - `brk` 容易产生堆内部的**空闲碎片**（如果堆顶的内存没释放，下面的内存即便 `free` 了也无法归还 OS）。
  - `mmap` 申请的是独立区域，释放即归还，不会产生堆内的碎片问题，但它是按“页”分配的，对于小对象会产生严重的**内部碎片**（why）。

### Q2：如果程序调用 malloc(100) 成功并返回指针 p，此时物理内存是否已经分配？如果接着执行 memset(p, 0, 100)，操作系统内核发生了什么？

**参考答案：**

1. **malloc 成功时：** 物理内存并没有分配。内核只是在进程的虚拟地址空间内标记了一段有效区域，并更新了 `mm_struct`。
2. **执行 memset 时：**
   - CPU 尝试访问虚拟地址 `p`，**MMU** 发现该虚拟页在页表中没有对应的物理页条目（Present位为0）。
   - 触发**缺页中断（Page Fault）**，CPU 切换到内核态。
   - 内核检查该地址是否合法，随后从**伙伴系统**中获取一个物理页框。
   - 更新**页表**，建立虚拟地址到物理页的映射。
   - 最后恢复进程运行，重新执行 `memset` 指令，此时访问成功。

### Q3：为什么 malloc 分配的内存块在 free 时不需要传入大小？这种设计有什么潜在风险？

**参考答案：**

- **设计原理：** `malloc` 在分配内存时，实际申请的空间比用户要求的大小多出几个字节。这多出来的部分（位于返回指针的前面）被称为 **Chunk Header（元数据）**，里面存储了该块的大小、状态（是否空闲）等信息。`free` 时只需将指针前移即可读出大小。
- **潜在风险：** * **堆溢出风险：** 如果程序发生写越界，修改了相邻 Chunk 的 Header（元数据），会导致 `free` 时读取到错误的长度或状态，从而引发 `double free` 或 `memory corruption` 崩溃。
  - **安全性：** 攻击者可以利用修改元数据的手段实施堆溢出攻击（如 Unlink 攻击）。

### Q4：在 64 位 Linux 系统中，如果一个进程不断 malloc 却不 free，最终会发生什么？

**参考答案：**

1. **地址空间耗尽（极难）：** 理论上 64 位虚拟地址空间极大（128TB+），单纯 `malloc` 很难耗尽虚拟地址。
2. **物理内存耗尽：** 随着程序读写这些内存，物理内存逐渐被占满。
3. **Swap 交换：** 系统会将部分不常用的物理页置换到磁盘的 Swap 分区，导致系统运行速度剧降（IO **抖动**）。
4. **OOM Killer：** 当物理内存和 Swap 都被耗尽时，Linux 内核的 **OOM Killer（Out of Memory Killer）** 机制会被触发。它会根据评分机制（占用内存多、运行时间短的进程得分高）挑选一个“倒霉”进程发送 `SIGKILL` 信号将其杀掉，以释放内存保障内核存活。