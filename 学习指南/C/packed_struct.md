# **C/C++ 结构体内存对齐与紧凑布局详解**

内存对齐是底层开发、网络协议定义及性能优化中的核心概念。以下是针对你四个问题的详细解答。

### **Q1：普通结构体的对齐规则是什么？**

普通结构体（非紧凑型）的对齐规则主要遵循以下三大准则：

1. **自然对齐（Member Alignment）：**  
   结构体中的每个成员，其偏移量（Offset）必须是该成员大小（或 pragma pack 指定值中较小者）的整数倍。  
   * 例如：int（4字节）的起始地址必须能被 4 整除；double（8字节）起始地址必须能被 8 整除。  
2. **结构体总体对齐（Structure Alignment）：**  
   结构体的总大小必须是其内部**最大基本类型成员**大小的整数倍。如果不足，编译器会在末尾填充（Padding）。  
3. **首地址对齐：**  
   结构体变量的首地址必须是其最宽基本类型成员的整数倍。

**为什么要对齐？**

* **平台原因：** 不是所有硬件平台都能访问任意地址上的任意数据。  
* **性能原因：** 处理器访问对齐的内存效率更高。若数据跨越了缓存行或总线宽度边界，需要两次内存访问。

### **Q2：紧凑型与普通结构体在内存中的排布举例**

假设有如下结构体：

struct MyStruct {  
    char a;    // 1 byte  
    int b;     // 4 bytes  
    char c;    // 1 byte  
};

#### **1\. 普通结构体（默认对齐，假设为 4 字节对齐方案）**

为了满足 int b 必须从 4 的倍数地址开始，编译器会插入填充字节：

| 偏移量 | 成员 | 内容 | 备注 |
| :---- | :---- | :---- | :---- |
| 0 | a | char | 占据 1 字节 |
| 1-3 | \- | **Padding** | **填充 3 字节**，使 b 对齐到 4 |
| 4-7 | b | int | 占据 4 字节 |
| 8 | c | char | 占据 1 字节 |
| 9-11 | \- | **Padding** | **填充 3 字节**，使总大小为 4 的倍数 |

**结果：** sizeof(MyStruct) \= **12 字节**。

#### **2\. 紧凑型结构体（Packed）**

去掉所有填充，按字节紧挨着排布：

| 偏移量 | 成员 | 内容 | 备注 |
| :---- | :---- | :---- | :---- |
| 0 | a | char | 占据 1 字节 |
| 1-4 | b | int | 占据 4 字节（从偏移量 1 开始，不对齐） |
| 5 | c | char | 占据 1 字节 |

**结果：** sizeof(MyStruct) \= **6 字节**。

### **Q3：\#pragma pack(push, 1\) 和 \#pragma pack(pop) 的含义**

这两行代码通常成对出现，用于**局部**改变编译器的对齐行为。

* **\#pragma pack(push, n)**：  
  1. **push**：将当前的对齐状态（Alignment state）压入编译器内部的一个栈中，以便后续恢复。  
  2. **n (例如 1\)**：设置新的对齐模数。1 表示按 1 字节对齐，即**取消所有填充**，使其变为紧凑型结构体。  
* **\#pragma pack(pop)**：  
  从栈顶弹出之前保存的对齐状态，恢复到执行 push 之前的设置。

**为什么要这么做？**

如果你直接写 \#pragma pack(1) 而不使用 push/pop，会影响到后续所有的代码（包括包含的头文件），这可能导致其他库在链接时出现严重的内存错误。使用 push/pop 可以确保这种修改只作用于特定的结构体。

### **Q4：attribute((packed)) 是什么？**

\_\_attribute\_\_((packed)) 是 **GCC/Clang/ARMCC** 等编译器的特有属性插件（编译器指令）。

* **作用**：它告诉编译器，对于被修饰的结构体，取消成员间的对齐填充，使用最小可能的空间进行排布（即按 1 字节对齐）。  
* **语法位置**：  
  struct MyPackedStruct {  
      char a;  
      int b;  
  } \_\_attribute\_\_((packed)); 

#### **术语称呼：**

1. **正式称呼**：**属性说明符（Attribute Specifier）**。  
2. **通用称呼**：**编译器属性（Compiler Attribute）** 或 **扩展属性**。  
3. **具体到位置**：  
   * 跟在 struct 关键字后面或结构体定义末尾的部分，称为 **Type Attribute（类型属性）**，因为它修饰的是整个结构体类型。  
   * 如果放在成员变量名后面，则称为 **Variable Attribute（变量属性）**。

#### **与 \#pragma pack 的区别：**

* \#pragma pack 是基于“全局/区域”的，影响之后的定义。  
* \_\_attribute\_\_((packed)) 是基于“类型”的，只针对定义的那一个结构体。  
* 在现代 C 跨平台开发中，通常会用宏来兼容两者。