# **C 语言基础知识常见疑问解答**

### **Q1：char 数组的赋值方式**

在 C 语言中，字符数组的赋值取决于它是处于**初始化阶段**还是**运行阶段**。

1. **定义时初始化**：  
   这是最简便的方式，可以直接使用字符串字面量。  
   char str1\[\] \= "Hello";          // 自动添加 '\\0'，数组长度为 6  
   char str2\[10\] \= {'H', 'e', 'l', 'l', 'o', '\\0'}; // 逐个字符赋值

2. **定义后的赋值（错误示例与正确示例）**： 注意：数组名在表达式中通常代表数组首地址，性质上类似于一个**指针常量**，其指向的地址不可改变，因此不能作为左值被赋值。  
   char str\[20\];  
   // str \= "Hello"; // ❌ 错误！不能直接给数组名赋值

   **正确方式**：  
   * 使用库函数 strcpy：  
     \#include \<string.h\>  
     strcpy(str, "Hello");

   * 使用 sprintf：  
     sprintf(str, "%s", "Hello");

   * 逐个元素赋值：  
     str\[0\] \= 'H'; str\[1\] \= 'e'; // ... 需手动处理 '\\0'

### **Q2：结构体申明与 struct 关键字**

#### **为什么申明时需要使用 struct 关键字？**

在 C 语言中，结构体名（标签，Tag）和普通的变量名（标识符）属于不同的**命名空间**。当你定义 struct User { ... }; 时，User 只是一个标签，编译器需要 struct 关键字来识别这是一个结构体类型。

#### **如何不使用 struct 关键字？**

最常用的方法是使用 typedef 关键字为结构体创建一个**类型别名**：

// 方式 A：先定义结构体，再定义别名  
struct Person {  
    char name\[20\];  
    int age;  
};  
typedef struct Person Person;

// 方式 B：定义时直接创建别名（最常用）  
typedef struct Student {  
    int id;  
} Student;

// 使用时：  
Student s1; // 此时不再需要写 struct

### **Q3：strcpy 传入参数的意义与要求**

strcpy 的原型通常为：

char \*strcpy(char \*dest, const char \*src);

1. **参数意义**：  
   * **第一个参数 (char \*dest)**：目标字符串指针。它是我们要写入数据的地方。由于需要修改内存内容，所以不加 const。  
   * **第二个参数 (const char \*src)**：源字符串指针。它是我们要读取数据的地方。  
2. **为什么第二个是 const char \*？**  
   * **安全性（只读保证）**：告知编译器和开发者，strcpy 函数内部**只会读取**源字符串，绝不会修改它的内容。  
   * **兼容性**：允许传入字符串常量（如 "Hello"），因为字符串常量本身就是不可修改的（其类型隐式接近 const char \*）。  
3. **对传入参数的要求**：  
   * **有效性**：dest 和 src 都不能是 NULL。  
   * **空间足够**：dest 指向的内存空间必须足以容纳 src 及其结尾的 \\0。  
   * **终止符**：src 指向的字符序列必须以 \\0 结尾。  
   * **禁止重叠**：dest 和 src 所指向的内存区域不能有重叠（否则结果未定义）。

### **Q4：char \* 与 const char \* 的区别**

这两者的核心区别在于**通过指针修改数据的权限**：

| 特性 | char \* | const char \* |
| :---- | :---- | :---- |
| **定义** | 指向字符的指针 | 指向字符常量的指针 |
| **数据修改** | 可以修改指针指向的内容 (\*p \= 'A') | **不可以**修改指向的内容 (\*p \= 'A' 会报错) |
| **指针移动** | 可以改变指针指向的地址 (p++) | 可以改变指针指向的地址 (p++) |
| **常见用途** | 存储可变字符串（如缓冲区） | 接收字符串常量或只读参数 |

### **Q5：常量指针 vs 指针常量**

这是 C 语言中最易混淆的一对概念。我们可以通过 **“倒过来读”** 的方法轻松分辨。

#### **1\. 常量指针 (Pointer to Constant)**

* **语法**：const int \*p 或 int const \*p  
* **含义**：**指向常量的指针**。  
* **特点**：指针指向的内容（\*p）是常量，不能通过该指针修改；但指针变量本身（p）存的地址可以改。  
* **例子**：  
  int a \= 10, b \= 20;  
  const int \*p \= \&a;  
  // \*p \= 15;  // ❌ 错误：不能修改指向的值  
  p \= \&b;      // ✅ 正确：可以修改指针指向的地址

#### **2\. 指针常量 (Constant Pointer)**

* **语法**：int \* const p  
* **含义**：**指针本身是一个常量**。  
* **特点**：指针存的地址（p）不能改，一旦初始化就锁定了；但可以通过指针修改它指向的内容（\*p）。  
* **例子**：  
  int a \= 10, b \= 20;  
  int \* const p \= \&a;  
  \*p \= 15;     // ✅ 正确：可以修改指向的值  
  // p \= \&b;   // ❌ 错误：不能修改指针存的地址

#### **总结对比表**

| 术语 | 英文 | 代码形式 | 谁不能变 | 记忆窍门 |
| :---- | :---- | :---- | :---- | :---- |
| **常量指针** | Pointer to Constant | const int \*p | 指向的内容 (\*p) | const 在 \* 之前，修饰的是值 |
| **指针常量** | Constant Pointer | int \* const p | 指针的地址 (p) | const 在 \* 之后，修饰的是指针 |
| **指向常量的指针常量** | Const Pointer to Const | const int \* const p | 都不许变 | 两个都锁死 |

**终极口诀：**

**左定值，右定向。**

const 在 \* 左边，锁定的是“值”；const 在 \* 右边，锁定的是“方向（地址）”。