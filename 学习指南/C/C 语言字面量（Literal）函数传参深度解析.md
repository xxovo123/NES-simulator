# **C 语言字面量（Literal）函数传参深度解析**

在 C 语言中，直接向函数传递“硬编码”的值（如数字、字符串或数组）而非命名变量时，编译器会根据字面量的类型采取不同的底层处理机制。

### **1\. 字符串字面量（String Literals）**

**示例：** memcmp(ptr, "NES\\x1A", 4);

* **存储位置**：**只读数据段（.rodata）**。  
* **传递机制**：**传址（Pass by Address）**。  
* **底层行为**：  
  * 编译器在 .rodata 中分配一块连续空间存储该字符串（含 \\0）。  
  * 在函数调用时，实际压入栈中或放入寄存器的是该字符串在数据段中的**首地址**。  
* **生命周期**：全局（静态）生命周期。程序运行期间始终有效。

### **2\. 数值字面量（Numeric Literals）**

**示例：** calculate\_area(10, 3.14); 或 sleep(5);

* **存储位置**：**代码段（.text）作为立即数**。  
* **传递机制**：**传值（Pass by Value）**。  
* **底层行为**：  
  * **立即数（Immediate Operand）**：对于较小的整数，数值直接编码在汇编指令中（例如 MOV EAX, 10）。  
  * **常量池**：对于较大的浮点数或某些架构下的长整数，编译器可能将其存放在代码段附近的“常量池”中，然后读取到寄存器。  
* **生命周期**：瞬时。一旦指令执行完毕，该字面量作为“对象”就不再独立存在。

### **3\. 字符字面量（Character Literals）**

**示例：** putchar('A');

* **本质**：在 C 中，'A' 的本质是整数（int）。  
* **底层行为**：与数值字面量完全一致，作为立即数传递其 ASCII 码值（65）。

### **4\. 复合字面量（Compound Literals）—— C99 特性**

**示例：** draw\_point((struct Point){10, 20}); 或 sum((int\[\]){1, 2, 3}, 3);

* **存储位置**：**栈（Stack）** 或 **只读数据段（.rodata）**。  
* **传递机制**：  
  * 如果作为结构体传递且未取地址：**传值**（拷贝整个结构体）。  
  * 如果作为数组传递：**传址**（传递栈上的临时数组首地址）。  
* **底层行为**：  
  * 编译器在当前函数的栈帧中创建一个匿名对象，并用字面量值进行初始化。  
* **生命周期**：**自动生命周期**。其作用域仅限于该字面量出现的代码块。

### **5\. 核心差异总结表**

| 字面量类型 | 示例 | 默认传递方式 | 内存区域 | 修改风险 |
| :---- | :---- | :---- | :---- | :---- |
| **字符串** | "Hello" | **地址** (char\*) | .rodata (只读) | 修改会导致运行时崩溃 |
| **整数** | 100 | **数值** (int) | 代码指令/寄存器 | 不可修改（无地址） |
| **浮点数** | 3.14 | **数值** (double) | 代码段常量池 | 不可修改（无地址） |
| **复合字面量** | (int\[\]){1,2} | **地址** (int\*) | 栈 (Stack) | 可修改（除非加 const） |

### **6\. 进阶解析：为什么 &10 是错的，而 "ABC" 可以取地址？**

这是初学者最容易困惑的地方：

* **左值（Lvalue）与右值（Rvalue）**：  
  * 10 是纯右值，它没有明确的内存地址，通常只存在于寄存器或指令流中。  
  * "ABC" 虽是字面量，但在 C 中它被视为**左值**。因为它代表了 .rodata 段中一块确定的、持久的内存空间。

### **7\. 性能影响**

* **字符串**：传递地址非常高效（仅 4/8 字节），无论字符串多长。  
* **小数字**：作为立即数是最快的寻址方式，直接硬编码在 CPU 指令中。  
* **大结构体字面量**：如果在调用时频繁创建复合字面量并传值，会产生大量的栈拷贝开销，建议传递指针。