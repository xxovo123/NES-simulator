# **第一阶段：iNES 文件解析操作指南**

这一步的目标是将硬盘上的 .nes 二进制文件读入内存，并识别出硬件配置信息。

## **1\. 核心任务：解析 16 字节头部 (Header)**

NES 文件并非纯代码，它有一个 16 字节的“身份证”。你需要按照以下逻辑进行操作：

### **A. 定义“紧凑型”结构体**

* **操作**：查阅 Nesdev Wiki 的 [iNES 页面](https://www.nesdev.org/wiki/INES)，定义一个结构体。  
* **复健点**：  
  * **数据类型**：使用 \<stdint.h\> 中的 uint8\_t。不要用 int，因为 int 的长度在不同机器上不一致。  
  * **内存对齐 (Padding)**：在 C 语言中，编译器可能会为了对齐而在结构体中插入空白。为了确保结构体刚好映射到文件的 16 字节，你需要学习如何使用 \#pragma pack(push, 1\) 或 \_\_attribute\_\_((packed))。

### **B. 验证文件合法性 (Magic Number)**

* **操作**：读取前 4 个字节。它们必须是 N, E, S, 0x1A。  
* **思考**：为什么是 0x1A？在旧的 DOS 系统中，0x1A 是 EOF（文件结束符），这可以防止你在控制台 cat 这个文件时导致屏幕乱码。

### **C. 计算存储器大小**

* **操作**：  
  * 提取第 4 个字节，乘以 16KB，得到 PRG-ROM (程序代码) 的总大小。  
  * 提取第 5 个字节，乘以 8KB，得到 CHR-ROM (图像数据) 的总大小。  
* **思考**：为什么单位是 16KB 和 8KB？这反映了 NES 硬件总线的地址空间划分。

### **D. 提取 Mapper ID (位运算练习)**

这是复健计算机组成原理的关键。NES 有数百种不同的扩展电路板（Mapper），ID 被拆分在了两个字节中。

* **操作**：  
  1. 获取第 6 字节的高 4 位（这是 Mapper ID 的低半字节）。  
  2. 获取第 7 字节的高 4 位（这是 Mapper ID 的高半字节）。  
  3. 将它们拼成一个 8 位的整数。  
* **技巧**：使用 (byte & 0xF0) 掩码配合 \>\> 移位和 | 或运算。

## **2\. 内存分配与数据读取**

解析完头部后，你需要把真正的“马里奥代码”搬进内存。

### **A. 处理可选的 Trainer**

* **操作**：检查第 6 字节的第 2 位（Bit 2）。如果为 1，说明文件头后面跟着 512 字节的旧式原始数据。  
* **技巧**：使用 fseek(fp, 512, SEEK\_CUR) 跳过这部分，或者将其读入。

### **B. 动态分配内存**

* **操作**：使用 malloc 为 PRG 和 CHR 分配对应的空间。  
* **复健点**：  
  * 记得检查 malloc 是否返回 NULL。  
  * 记得在程序结束或出错时 free。

## **3\. 推荐的调试工具：十六进制编辑器**

在写代码之前，先找一个十六进制编辑器（如 **ImHex**、**HxD** 或 VS Code 的 **Hex Editor** 插件）手动打开 mario.nes。

* **练习**：  
  1. 手动找出前 4 个字节。  
  2. 找到第 4 和第 5 字节，口算出这个 ROM 的大小。  
  3. 查看第 6 和第 7 字节，手动通过位运算计算出 Mapper ID 是不是 0。

## **4\. 任务清单 (自测用)**

* \[ \] 我是否定义了符合 16 字节标准的 struct？  
* \[ \] 我是否处理了文件读取失败（例如文件不存在）的情况？  
* \[ \] 我是否能正确区分 Vertical Mirroring 和 Horizontal Mirroring（第 6 字节第 0 位）？这会直接影响后续 PPU 的渲染。  
* \[ \] 我是否成功打印出了 PRG-ROM 的前几个字节，并能与十六进制编辑器中的内容对上？