这是一个非常经典的NES（FC）模拟器开发问题，触及了6502 CPU架构的核心设计理念。

这里是针对你三个疑问的详细解答：

### **1\. NES模拟器中的“页”（Page）是多大？**

在NES使用的 MOS 6502（及其变种 Ricoh 2A03）处理器架构中：

* **页的大小（Page Size）是 256 字节（Bytes）。**

**原因：**

6502 是 **8位** 处理器，但拥有 **16位** 的地址总线（可以寻址 $2^{16} \= 65536$ 字节，即 64KB）。

为了处理方便，CPU将这 16位 地址 $HHLL 分为两部分：

* **高8位 ($HH)：** 代表 **页号** (Page Number)，范围 $00 \- $FF。  
* **低8位 ($LL)：** 代表 **页内偏移** (Offset)，范围 $00 \- $FF (0-255)。

因此，内存 $0000-$00FF 是第0页（Zero Page），$0100-$01FF 是第1页（通常用于堆栈），以此类推直到第255页。

### ---

**2\. 既然64KB内存是统一的，为什么会有“跨页”？**

这是一个极好的直觉问题。虽然从 **存储器（RAM/ROM）** 的物理角度看，内存确实是一块连续的 64KB 空间，但在 **CPU 内部的运算逻辑（ALU）** 看来，情况并非如此。

问题的核心在于：**6502 是一个 8位 CPU，它的算术逻辑单元（ALU）一次只能处理 8位 数据。**

#### **“跨页”的本质是进位（Carry）**

当你执行 **绝对X变址寻址 (Absolute, X)** 指令时，CPU 需要计算最终的物理地址。

假设指令是 LDA $base, X，计算公式是 Target Address \= $base \+ X。

CPU 计算这个地址是分步进行的：

1. **第一步：** CPU 取出基地址的 **低8位**，加上寄存器 **X** 的值。  
2. **第二步：**  
   * **情况 A（不跨页）：** 如果 低8位 \+ X 的结果小于 256（没有进位），CPU 直接知道高8位不需要改变。计算结束，直接去读内存。  
   * **情况 B（跨页）：** 如果 低8位 \+ X 的结果溢出了（大于 255），产生了一个 **进位（Carry）**。  
3. **第三步（修正）：** 因为产生了进位，CPU 必须花费额外的时间（1个时钟周期）将基地址的 **高8位** 加 1。这就叫“跨页”。

#### **举个例子**

假设 X 寄存器的值是 $10 (十进制 16)。

* **不跨页的情况：**  
  指令 LDA $1000, X  
  计算：低位 $00 \+ $10 \= $10 (没有进位)。  
  高位 $10 保持不变。  
  最终地址：$1010。  
  **耗时：** 4个周期（CPU不需要修正高位）。  
* **跨页的情况：**  
  指令 LDA $10F0, X  
  计算：低位 $F0 \+ $10 \= $100 (发生溢出/进位！低8位变成 $00)。  
  CPU 此时必须停下来，把进位加到高位 $10 上，使其变成 $11。  
  最终地址：$1100。  
  **耗时：** 5个周期（多出的1个周期用来修正高位）。

### ---

**3\. 为什么这对模拟器很重要？**

在编写 NES 模拟器时，**精度（Accuracy）** 至关重要。

NES 的很多游戏（特别是像《忍者蛙》、《超级马里奥兄弟3》等利用了高级光栅特效的游戏）极度依赖 CPU 的时序。如果你的模拟器忽略了这“多出来的 1 个周期”，CPU 的运行速度就会比真实的 NES 稍微快一点点。

虽然单次指令只差 1 个周期，但每秒几百万次运算累积下来，就会导致 CPU 和 PPU（图像处理器）甚至 APU（音频处理器）失去同步，造成画面撕裂、滚动错误或者音画不同步。

### **总结**

* **页大小：** 256字节。  
* **统一内存的误区：** 内存是统一的，但 CPU 的加法器是 8 位的。  
* **跨页的实质：** 仅仅是因为 低8位 \+ X 产生了进位，导致 CPU 需要额外的时间去计算高8位的新值。

### **下一步建议**

既然你在研究寻址模式的细节，可能正准备实现 CPU 的核心循环。

**你需要我为你提供一段 C 或 C++ 代码示例，展示如何在模拟器中正确检测并处理这种“跨页周期惩罚”吗？**