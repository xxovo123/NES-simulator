这是一个非常经典的硬件设计细节，也是 6502 CPU 最著名的“特性”之一。要真正理解这个 Bug，我们需要先拆解**间接寻址 (Indirect Addressing)** 的正常逻辑，然后深入到硬件层面看它为什么会在页面边界（Page Boundary）处“犯傻”。

### **1\. 什么是间接寻址？（正常情况）**

**间接寻址**就像是寻宝游戏中的“线索盒”。

* **指令**：JMP ($1000)  
* **含义**：不要直接跳到 $1000！请去 $1000 这个地址看一看，那里存放着一张纸条，纸条上写着的**新地址**，才是你真正要去的地方。

在 6502 中，地址是 16 位的（2 个字节）。所以，为了获取这个“新地址”，CPU 需要读两次内存：

1. **读低 8 位**：去 $1000 读取低字节（Low Byte）。  
2. **读高 8 位**：去 $1001（也就是 $1000 \+ 1）读取高字节（High Byte）。

**图示（正常）：**

假设内存如下：

* $1000: 55  
* $1001: C0

执行 JMP ($1000)：

1. 读 $1000 得到 $55。  
2. 读 $1001 得到 $C0。  
3. 拼合地址：$C055。  
4. **PC 跳转到 $C055**。-\> **正确！**

### ---

**2\. 这个 Bug 是什么？（异常情况）**

Bug 发生在**指针地址恰好在页面的最后一个字节**（即以 $FF 结尾，如 $10FF）时。

如果我们执行 JMP ($10FF)，按照逻辑，CPU 应该这样做：

1. **读低 8 位**：去 $10FF 读取。  
2. **读高 8 位**：去 $10FF \+ 1 \= **$1100** 读取。

**但在真实硬件上，第 2 步出错了！**

CPU 并没有去 $1100，而是回到了本页的开头 **$1000** 去读取高字节。

**图示（Bug 现场）：**

假设内存如下（注意跨页了）：

* $10FF: 55 (这是第 10 页的最后一个字节)  
* $1100: C0 (这是第 11 页的第一个字节，**正确的高位在理应这里**)  
* $1000: 00 (这是第 10 页的第一个字节，**错误的高位被读到了这里**)

执行 JMP ($10FF)：

1. 读 $10FF 得到 $55。  
2. 试图读高位，但硬件读了 **$1000**，得到 $00。  
3. 拼合地址：$0055。  
4. **PC 跳转到 $0055**。 \-\> **大错特错！** 此时程序通常会崩溃。

### ---

**3\. 为什么会发生这种事？（硬件原理）**

你可能会问：“CPU 连加法都算不对吗？$10FF \+ 1 不就是 $1100 吗？”

其实，这源于 1975 年 6502 设计时的**成本节约策略**。

1. **独立的地址生成器**：为了速度，取指单元并没有使用主 ALU（算术逻辑单元）来计算这个“+1”的操作。它使用了一个更简单的、独立的硬件电路来计算读取高位的地址。  
2. **8 位自增器**：为了省晶体管，这个独立的地址计算电路**只有 8 位宽度**，它只负责处理地址的低 8 位。地址的高 8 位是直接锁存（Latch）保持不变的。

**还原当时的电路逻辑：**

* **目标基地址**：$10FF (高位 10, 低位 FF)  
* **计算低字节地址**：读 $10FF。 \-\> OK。  
* **计算高字节地址**：  
  * **低位部分**：硬件将低位 FF 放入 8 位自增器。$FF \+ 1 在 8 位下溢出变为 $00。  
  * **高位部分**：硬件**没有进位逻辑**去通知高位寄存器“嘿，低位溢出了，你也加 1 吧”。高位寄存器依然保持原来的 $10。  
  * **结果**：高位 $10 \+ 低位 $00 \= **$1000**。

这就是所谓的\*\*“页面回卷 Bug” (Page Boundary Wrap-around Bug)\*\*。

### **4\. 代码中的模拟实现**

为了让模拟器能够精确运行那些依赖（或者无意触发）了这个 Bug 的老游戏，我们在代码中必须**手动模拟**这个错误的逻辑。

这就是 addr\_ind 函数中那个 if 判断的由来：

C

static uint8\_t addr\_ind(CPU\* cpu) {  
    // 1\. 读取指令给出的指针地址（例如 $10FF）  
    uint16\_t ptr\_lo \= cpu\_read(cpu, cpu-\>pc++);  
    uint16\_t ptr\_hi \= cpu\_read(cpu, cpu-\>pc++);  
    uint16\_t ptr \= (ptr\_hi \<\< 8) | ptr\_lo;

    // 2\. 模拟 Bug  
    if ((ptr & 0x00FF) \== 0x00FF) { // 如果指针地址低位是 $FF  
        // 错误行为：  
        // 低位：从 ptr 读取 ($10FF)  
        // 高位：从 ptr & 0xFF00 读取 (强行抹去低位，变成 $1000)  
        cpu-\>addr\_abs \= (cpu\_read(cpu, ptr & 0xFF00) \<\< 8) | cpu\_read(cpu, ptr);  
    } else {  
        // 正常行为：  
        // 低位：从 ptr 读取 ($1000)  
        // 高位：从 ptr \+ 1 读取 ($1001)  
        cpu-\>addr\_abs \= (cpu\_read(cpu, ptr \+ 1) \<\< 8) | cpu\_read(cpu, ptr);  
    }  
    return 0;  
}

### **总结**

这个 Bug 的本质是 **6502 在处理间接寻址读取高字节时，地址寄存器的低 8 位溢出无法进位到高 8 位**。

* **对于开发者**：当年的 NES 程序员必须非常小心，绝对不能把跳转表（Jump Table）的指针放在页面的边界（$xxFF）上，否则程序就会飞掉。  
* **对于模拟器**：如果我们修复了这个 Bug（实现了正确的加法），反而会导致那些利用了此特性或者偶然触发此逻辑的游戏运行错误。所以我们必须“**将错就错**”。