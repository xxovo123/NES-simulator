# **NES 模拟器架构：Bus 总线详解**

在 NES 模拟器中，**Bus（总线）** 是核心枢纽。它连接了 CPU、PPU、APU 以及插入的卡带（ROM）。它的主要职责是根据 CPU 给出的 **16位地址**，决定将数据路由（Route）到哪一个硬件组件。

## **1\. 核心职责：中转与路由**

CPU 本身并不关心数据存储在哪里，它只通过 bus\_read 和 bus\_write 两个接口进行操作。

* **解耦**：CPU 不需要知道 RAM 的大小或 PPU 的寄存器地址，一切由 Bus 进行内部地址解码。  
* **模拟物理连线**：在真实的 NES 电路板上，总线是由一系列导线和解码芯片组成的逻辑。

## **2\. CPU 内存映射表 (Memory Map)**

根据你的 bus.c 代码实现，NES CPU 的 64KB ($0000 \- $FFFF) 地址空间划分如下：

| 地址范围 | 大小 | 描述 | 代码逻辑实现 |
| :---- | :---- | :---- | :---- |
| **$0000 \- $1FFF** | 8KB | **CPU RAM** (及 3 个镜像) | addr & 0x07FF (映射到 2KB 实体 RAM) |
| **$2000 \- $3FFF** | 8KB | **PPU 寄存器** (及镜像) | addr & 0x0007 (映射到 8 个寄存器) |
| **$4000 \- $4017** | 24B | APU 与 IO 寄存器 | 暂未实现 |
| **$4018 \- $401F** | 8B | 禁用的测试模式 | 忽略 |
| **$4020 \- $7FFF** | \~16KB | **卡带空间** (Mapper 寄存器/RAM) | 属于 cartridge 范围 |
| **$8000 \- $FFFF** | 32KB | **PRG-ROM** (游戏程序代码) | 从 cartridge-\>prg\_rom 读取 |

## **3\. 代码关键技术点解析**

### **3.1 内存镜像逻辑 (Mirroring)**

在 bus.c 中，你使用了位运算 addr & 0x07FF：

if(addr \>= 0x0000 && addr \<= 0x1FFF){  
    return bus-\>ram\[addr & 0x07FF\];  
}

**为什么要这样做？**

* NES 实际只有 **2KB** 的物理 RAM（地址范围 $0000-$07FF）。  
* 但 CPU 给 RAM 分配了 **8KB** 的空间（$0000-$1FFF）。  
* 硬件上，地址线的高位在这一段没有连接，导致 $0800-$0FFF、$1000-$17FF、$1800-$1FFF 实际上访问的都是同一个物理 2KB 空间。  
* 0x07FF 的二进制是 0000 0111 1111 1111。通过 & 运算，地址中超出 $07FF 的高位会被强行清零，从而实现“循环映射”。

### **3.2 PRG-ROM 的读取逻辑**

在 bus\_read 的 $8000-$FFFF 区域：

uint32\_t offset \= addr \- 0x8000;  
uint32\_t prg\_size\_bytes \= bus-\>cartridge-\>header.prg\_size \* 16 \* 1024;  
return bus-\>cartridge-\>prg\_rom\[offset % prg\_size\_bytes\];

* **NROM (Mapper 0\)**：最简单的卡带。如果 PRG-ROM 是 16KB，它会被镜像到 $8000 和 $C000 两个位置。  
* **取模运算 (%)**：当 PRG 只有 16KB 时，访问 $C000 ($C000-$8000=16384) 会因为 16384 % 16384 \= 0 而重新读回 ROM 的开头。

## **4\. 后续需要完成的内容**

目前的 Bus 只是一个雏形，要让模拟器跑起来，还需要完成以下关键模块：

### **4.1 PPU 寄存器连接 (核心难点)**

PPU（图像处理器）通过 8 个寄存器与 CPU 交互。你需要在 Bus 中引入 PPU 结构体：

* **$2000** (PPUCTRL), **$2001** (PPUMASK) 等。  
* 当 CPU 写入 $2000 时，实际上是改变了 PPU 的渲染模式。  
* **TODO**: 在 bus\_write 中调用 ppu\_write(bus-\>ppu, addr & 0x0007, data)。

### **4.2 Mapper 系统的抽象**

目前的逻辑直接写死在 Bus 里（默认了 Mapper 0）。

* **完善建议**：创建一个 Mapper 结构体。不同的游戏有不同的 Mapper（如 MMC1, MMC3）。  
* 将 bus\_read 中 $8000 以上的逻辑交给 mapper\_read(bus-\>cartridge, addr) 处理。

### **4.3 输入设备 (Controller)**

NES 手柄通过 $4016 和 $4017 端口读取。

* 这是一个串行接口。CPU 先往 $4016 写一个 1 再写一个 0（锁存），然后连续读 8 次 $4016 来获取 A, B, Select, Start 等按键状态。

### **4.4 DMA (直接内存访问)**

这是一个特殊的总线行为。当 CPU 往 \*\*$4014\*\* 写入一个值 XX 时，Bus 需要立即暂停 CPU，将 CPU RAM 中 $XX00-$XXFF\\ 的 256 字节数据快速拷贝到 PPU 的 OAM（精灵内存）中。

## **5\. 开发建议总结**

1. **先跑通 CPU 指令**：现在的 Bus 已经足以支撑 CPU 读取指令了。你可以尝试让 CPU 从 $FFFC-$FFFD 读取复位向量（Reset Vector），跳转到 ROM 程序开始执行。  
2. **严格遵守镜像规则**：NES 的很多老游戏利用了内存镜像特性，如果地址解码不准确，游戏会崩溃。  
3. **PPU 是接下来的重点**：一旦 CPU 能跑，下一步就是完成 PPU 寄存器的读写，因为几乎所有游戏初始化后都会疯狂操作 PPU 寄存器。